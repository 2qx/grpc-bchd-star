// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bchrpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Bchrpc.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(Block);
GPBObjCClassDeclaration(BlockInfo);
GPBObjCClassDeclaration(Block_TransactionData);
GPBObjCClassDeclaration(GetMempoolResponse);
GPBObjCClassDeclaration(GetMempoolResponse_TransactionData);
GPBObjCClassDeclaration(MempoolTransaction);
GPBObjCClassDeclaration(Transaction);
GPBObjCClassDeclaration(TransactionFilter);
GPBObjCClassDeclaration(Transaction_Input);
GPBObjCClassDeclaration(Transaction_Input_Outpoint);
GPBObjCClassDeclaration(Transaction_Output);
GPBObjCClassDeclaration(UnspentOutput);

#pragma mark - BchrpcRoot

@implementation BchrpcRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - BchrpcRoot_FileDescriptor

static GPBFileDescriptor *BchrpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"pb"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GetMempoolInfoRequest

@implementation GetMempoolInfoRequest


typedef struct GetMempoolInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} GetMempoolInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolInfoRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetMempoolInfoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMempoolInfoResponse

@implementation GetMempoolInfoResponse

@dynamic size;
@dynamic bytes;

typedef struct GetMempoolInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t size;
  uint32_t bytes;
} GetMempoolInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMempoolInfoResponse_FieldNumber_Size,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMempoolInfoResponse__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bytes",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMempoolInfoResponse_FieldNumber_Bytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMempoolInfoResponse__storage_, bytes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolInfoResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMempoolInfoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMempoolRequest

@implementation GetMempoolRequest

@dynamic fullTransactions;

typedef struct GetMempoolRequest__storage_ {
  uint32_t _has_storage_[1];
} GetMempoolRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullTransactions",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMempoolRequest_FieldNumber_FullTransactions,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMempoolRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMempoolResponse

@implementation GetMempoolResponse

@dynamic transactionDataArray, transactionDataArray_Count;

typedef struct GetMempoolResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionDataArray;
} GetMempoolResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionDataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GetMempoolResponse_TransactionData),
        .number = GetMempoolResponse_FieldNumber_TransactionDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMempoolResponse__storage_, transactionDataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMempoolResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMempoolResponse_TransactionData

@implementation GetMempoolResponse_TransactionData

@dynamic txidsOrTxsOneOfCase;
@dynamic transactionHash;
@dynamic transaction;

typedef struct GetMempoolResponse_TransactionData__storage_ {
  uint32_t _has_storage_[2];
  NSData *transactionHash;
  Transaction *transaction;
} GetMempoolResponse_TransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMempoolResponse_TransactionData_FieldNumber_TransactionHash,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetMempoolResponse_TransactionData__storage_, transactionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = GetMempoolResponse_TransactionData_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetMempoolResponse_TransactionData__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolResponse_TransactionData class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMempoolResponse_TransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "txidsOrTxs",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(GetMempoolResponse)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetMempoolResponse_TransactionData_ClearTxidsOrTxsOneOfCase(GetMempoolResponse_TransactionData *message) {
  GPBDescriptor *descriptor = [GetMempoolResponse_TransactionData descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetBlockchainInfoRequest

@implementation GetBlockchainInfoRequest


typedef struct GetBlockchainInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} GetBlockchainInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockchainInfoRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetBlockchainInfoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockchainInfoResponse

@implementation GetBlockchainInfoResponse

@dynamic bitcoinNet;
@dynamic bestHeight;
@dynamic bestBlockHash;
@dynamic difficulty;
@dynamic medianTime;
@dynamic txIndex;
@dynamic addrIndex;

typedef struct GetBlockchainInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  GetBlockchainInfoResponse_BitcoinNet bitcoinNet;
  int32_t bestHeight;
  NSData *bestBlockHash;
  double difficulty;
  int64_t medianTime;
} GetBlockchainInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bitcoinNet",
        .dataTypeSpecific.enumDescFunc = GetBlockchainInfoResponse_BitcoinNet_EnumDescriptor,
        .number = GetBlockchainInfoResponse_FieldNumber_BitcoinNet,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockchainInfoResponse__storage_, bitcoinNet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bestHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockchainInfoResponse_FieldNumber_BestHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetBlockchainInfoResponse__storage_, bestHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bestBlockHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockchainInfoResponse_FieldNumber_BestBlockHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetBlockchainInfoResponse__storage_, bestBlockHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "difficulty",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockchainInfoResponse_FieldNumber_Difficulty,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetBlockchainInfoResponse__storage_, difficulty),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "medianTime",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockchainInfoResponse_FieldNumber_MedianTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetBlockchainInfoResponse__storage_, medianTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockchainInfoResponse_FieldNumber_TxIndex,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "addrIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockchainInfoResponse_FieldNumber_AddrIndex,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockchainInfoResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockchainInfoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetBlockchainInfoResponse_BitcoinNet_RawValue(GetBlockchainInfoResponse *message) {
  GPBDescriptor *descriptor = [GetBlockchainInfoResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetBlockchainInfoResponse_FieldNumber_BitcoinNet];
  return GPBGetMessageRawEnumField(message, field);
}

void SetGetBlockchainInfoResponse_BitcoinNet_RawValue(GetBlockchainInfoResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [GetBlockchainInfoResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetBlockchainInfoResponse_FieldNumber_BitcoinNet];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum GetBlockchainInfoResponse_BitcoinNet

GPBEnumDescriptor *GetBlockchainInfoResponse_BitcoinNet_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Mainnet\000Regtest\000Testnet3\000Simnet\000";
    static const int32_t values[] = {
        GetBlockchainInfoResponse_BitcoinNet_Mainnet,
        GetBlockchainInfoResponse_BitcoinNet_Regtest,
        GetBlockchainInfoResponse_BitcoinNet_Testnet3,
        GetBlockchainInfoResponse_BitcoinNet_Simnet,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetBlockchainInfoResponse_BitcoinNet)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetBlockchainInfoResponse_BitcoinNet_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetBlockchainInfoResponse_BitcoinNet_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetBlockchainInfoResponse_BitcoinNet_Mainnet:
    case GetBlockchainInfoResponse_BitcoinNet_Regtest:
    case GetBlockchainInfoResponse_BitcoinNet_Testnet3:
    case GetBlockchainInfoResponse_BitcoinNet_Simnet:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetBlockInfoRequest

@implementation GetBlockInfoRequest

@dynamic hashOrHeightOneOfCase;
@dynamic hash_p;
@dynamic height;

typedef struct GetBlockInfoRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t height;
  NSData *hash_p;
} GetBlockInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockInfoRequest_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockInfoRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockInfoRequest_FieldNumber_Height,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockInfoRequest__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockInfoRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockInfoRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "hashOrHeight",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetBlockInfoRequest_ClearHashOrHeightOneOfCase(GetBlockInfoRequest *message) {
  GPBDescriptor *descriptor = [GetBlockInfoRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetBlockInfoResponse

@implementation GetBlockInfoResponse

@dynamic hasInfo, info;

typedef struct GetBlockInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  BlockInfo *info;
} GetBlockInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockInfo),
        .number = GetBlockInfoResponse_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockInfoResponse__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockInfoResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockInfoResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockRequest

@implementation GetBlockRequest

@dynamic hashOrHeightOneOfCase;
@dynamic hash_p;
@dynamic height;
@dynamic fullTransactions;

typedef struct GetBlockRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t height;
  NSData *hash_p;
} GetBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockRequest_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockRequest_FieldNumber_Height,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockRequest__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fullTransactions",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockRequest_FieldNumber_FullTransactions,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "hashOrHeight",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetBlockRequest_ClearHashOrHeightOneOfCase(GetBlockRequest *message) {
  GPBDescriptor *descriptor = [GetBlockRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetBlockResponse

@implementation GetBlockResponse

@dynamic hasBlock, block;

typedef struct GetBlockResponse__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} GetBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.clazz = GPBObjCClass(Block),
        .number = GetBlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRawBlockRequest

@implementation GetRawBlockRequest

@dynamic hashOrHeightOneOfCase;
@dynamic hash_p;
@dynamic height;

typedef struct GetRawBlockRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t height;
  NSData *hash_p;
} GetRawBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawBlockRequest_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetRawBlockRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawBlockRequest_FieldNumber_Height,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetRawBlockRequest__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRawBlockRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRawBlockRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "hashOrHeight",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetRawBlockRequest_ClearHashOrHeightOneOfCase(GetRawBlockRequest *message) {
  GPBDescriptor *descriptor = [GetRawBlockRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetRawBlockResponse

@implementation GetRawBlockResponse

@dynamic block;

typedef struct GetRawBlockResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *block;
} GetRawBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawBlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRawBlockResponse__storage_, block),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRawBlockResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRawBlockResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockFilterRequest

@implementation GetBlockFilterRequest

@dynamic hashOrHeightOneOfCase;
@dynamic hash_p;
@dynamic height;

typedef struct GetBlockFilterRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t height;
  NSData *hash_p;
} GetBlockFilterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockFilterRequest_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockFilterRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockFilterRequest_FieldNumber_Height,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockFilterRequest__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockFilterRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockFilterRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "hashOrHeight",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetBlockFilterRequest_ClearHashOrHeightOneOfCase(GetBlockFilterRequest *message) {
  GPBDescriptor *descriptor = [GetBlockFilterRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetBlockFilterResponse

@implementation GetBlockFilterResponse

@dynamic filter;

typedef struct GetBlockFilterResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *filter;
} GetBlockFilterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filter",
        .dataTypeSpecific.clazz = Nil,
        .number = GetBlockFilterResponse_FieldNumber_Filter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockFilterResponse__storage_, filter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockFilterResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockFilterResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetHeadersRequest

@implementation GetHeadersRequest

@dynamic blockLocatorHashesArray, blockLocatorHashesArray_Count;
@dynamic stopHash;

typedef struct GetHeadersRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockLocatorHashesArray;
  NSData *stopHash;
} GetHeadersRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockLocatorHashesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetHeadersRequest_FieldNumber_BlockLocatorHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHeadersRequest__storage_, blockLocatorHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "stopHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetHeadersRequest_FieldNumber_StopHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetHeadersRequest__storage_, stopHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetHeadersRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetHeadersRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetHeadersResponse

@implementation GetHeadersResponse

@dynamic headersArray, headersArray_Count;

typedef struct GetHeadersResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *headersArray;
} GetHeadersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headersArray",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockInfo),
        .number = GetHeadersResponse_FieldNumber_HeadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetHeadersResponse__storage_, headersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetHeadersResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetHeadersResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionRequest

@implementation GetTransactionRequest

@dynamic hash_p;

typedef struct GetTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
} GetTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetTransactionRequest_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTransactionRequest__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTransactionResponse

@implementation GetTransactionResponse

@dynamic hasTransaction, transaction;

typedef struct GetTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transaction;
} GetTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = GetTransactionResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTransactionResponse__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTransactionResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTransactionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRawTransactionRequest

@implementation GetRawTransactionRequest

@dynamic hash_p;

typedef struct GetRawTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
} GetRawTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawTransactionRequest_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRawTransactionRequest__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRawTransactionRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRawTransactionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRawTransactionResponse

@implementation GetRawTransactionResponse

@dynamic transaction;

typedef struct GetRawTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *transaction;
} GetRawTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawTransactionResponse_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRawTransactionResponse__storage_, transaction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRawTransactionResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRawTransactionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressTransactionsRequest

@implementation GetAddressTransactionsRequest

@dynamic startBlockOneOfCase;
@dynamic address;
@dynamic nbSkip;
@dynamic nbFetch;
@dynamic hash_p;
@dynamic height;

typedef struct GetAddressTransactionsRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t nbSkip;
  uint32_t nbFetch;
  int32_t height;
  NSString *address;
  NSData *hash_p;
} GetAddressTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressTransactionsRequest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressTransactionsRequest__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nbSkip",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressTransactionsRequest_FieldNumber_NbSkip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetAddressTransactionsRequest__storage_, nbSkip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nbFetch",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressTransactionsRequest_FieldNumber_NbFetch,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetAddressTransactionsRequest__storage_, nbFetch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressTransactionsRequest_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetAddressTransactionsRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressTransactionsRequest_FieldNumber_Height,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetAddressTransactionsRequest__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressTransactionsRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressTransactionsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "startBlock",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetAddressTransactionsRequest_ClearStartBlockOneOfCase(GetAddressTransactionsRequest *message) {
  GPBDescriptor *descriptor = [GetAddressTransactionsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetAddressTransactionsResponse

@implementation GetAddressTransactionsResponse

@dynamic confirmedTransactionsArray, confirmedTransactionsArray_Count;
@dynamic unconfirmedTransactionsArray, unconfirmedTransactionsArray_Count;

typedef struct GetAddressTransactionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *confirmedTransactionsArray;
  NSMutableArray *unconfirmedTransactionsArray;
} GetAddressTransactionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confirmedTransactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = GetAddressTransactionsResponse_FieldNumber_ConfirmedTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAddressTransactionsResponse__storage_, confirmedTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unconfirmedTransactionsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(MempoolTransaction),
        .number = GetAddressTransactionsResponse_FieldNumber_UnconfirmedTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAddressTransactionsResponse__storage_, unconfirmedTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressTransactionsResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressTransactionsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRawAddressTransactionsRequest

@implementation GetRawAddressTransactionsRequest

@dynamic startBlockOneOfCase;
@dynamic address;
@dynamic nbSkip;
@dynamic nbFetch;
@dynamic hash_p;
@dynamic height;

typedef struct GetRawAddressTransactionsRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t nbSkip;
  uint32_t nbFetch;
  int32_t height;
  NSString *address;
  NSData *hash_p;
} GetRawAddressTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsRequest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsRequest__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nbSkip",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsRequest_FieldNumber_NbSkip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsRequest__storage_, nbSkip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nbFetch",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsRequest_FieldNumber_NbFetch,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsRequest__storage_, nbFetch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsRequest_FieldNumber_Hash_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsRequest_FieldNumber_Height,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsRequest__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRawAddressTransactionsRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRawAddressTransactionsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "startBlock",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetRawAddressTransactionsRequest_ClearStartBlockOneOfCase(GetRawAddressTransactionsRequest *message) {
  GPBDescriptor *descriptor = [GetRawAddressTransactionsRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - GetRawAddressTransactionsResponse

@implementation GetRawAddressTransactionsResponse

@dynamic confirmedTransactionsArray, confirmedTransactionsArray_Count;
@dynamic unconfirmedTransactionsArray, unconfirmedTransactionsArray_Count;

typedef struct GetRawAddressTransactionsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *confirmedTransactionsArray;
  NSMutableArray *unconfirmedTransactionsArray;
} GetRawAddressTransactionsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "confirmedTransactionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsResponse_FieldNumber_ConfirmedTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsResponse__storage_, confirmedTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unconfirmedTransactionsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetRawAddressTransactionsResponse_FieldNumber_UnconfirmedTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetRawAddressTransactionsResponse__storage_, unconfirmedTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRawAddressTransactionsResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRawAddressTransactionsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressUnspentOutputsRequest

@implementation GetAddressUnspentOutputsRequest

@dynamic address;
@dynamic includeMempool;

typedef struct GetAddressUnspentOutputsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} GetAddressUnspentOutputsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressUnspentOutputsRequest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressUnspentOutputsRequest__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "includeMempool",
        .dataTypeSpecific.clazz = Nil,
        .number = GetAddressUnspentOutputsRequest_FieldNumber_IncludeMempool,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressUnspentOutputsRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressUnspentOutputsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressUnspentOutputsResponse

@implementation GetAddressUnspentOutputsResponse

@dynamic outputsArray, outputsArray_Count;

typedef struct GetAddressUnspentOutputsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *outputsArray;
} GetAddressUnspentOutputsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outputsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(UnspentOutput),
        .number = GetAddressUnspentOutputsResponse_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetAddressUnspentOutputsResponse__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressUnspentOutputsResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressUnspentOutputsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUnspentOutputRequest

@implementation GetUnspentOutputRequest

@dynamic hash_p;
@dynamic index;
@dynamic includeMempool;

typedef struct GetUnspentOutputRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSData *hash_p;
} GetUnspentOutputRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputRequest_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUnspentOutputRequest__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputRequest_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetUnspentOutputRequest__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "includeMempool",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputRequest_FieldNumber_IncludeMempool,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUnspentOutputRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUnspentOutputRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUnspentOutputResponse

@implementation GetUnspentOutputResponse

@dynamic hasOutpoint, outpoint;
@dynamic pubkeyScript;
@dynamic value;
@dynamic isCoinbase;
@dynamic blockHeight;

typedef struct GetUnspentOutputResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t blockHeight;
  Transaction_Input_Outpoint *outpoint;
  NSData *pubkeyScript;
  int64_t value;
} GetUnspentOutputResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outpoint",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Input_Outpoint),
        .number = GetUnspentOutputResponse_FieldNumber_Outpoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUnspentOutputResponse__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pubkeyScript",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputResponse_FieldNumber_PubkeyScript,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetUnspentOutputResponse__storage_, pubkeyScript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputResponse_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetUnspentOutputResponse__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isCoinbase",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputResponse_FieldNumber_IsCoinbase,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = GetUnspentOutputResponse_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetUnspentOutputResponse__storage_, blockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUnspentOutputResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUnspentOutputResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMerkleProofRequest

@implementation GetMerkleProofRequest

@dynamic transactionHash;

typedef struct GetMerkleProofRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *transactionHash;
} GetMerkleProofRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMerkleProofRequest_FieldNumber_TransactionHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMerkleProofRequest__storage_, transactionHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMerkleProofRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMerkleProofRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMerkleProofResponse

@implementation GetMerkleProofResponse

@dynamic hasBlock, block;
@dynamic hashesArray, hashesArray_Count;
@dynamic flags;

typedef struct GetMerkleProofResponse__storage_ {
  uint32_t _has_storage_[1];
  BlockInfo *block;
  NSMutableArray *hashesArray;
  NSData *flags;
} GetMerkleProofResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockInfo),
        .number = GetMerkleProofResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetMerkleProofResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hashesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMerkleProofResponse_FieldNumber_HashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMerkleProofResponse__storage_, hashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = GetMerkleProofResponse_FieldNumber_Flags,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetMerkleProofResponse__storage_, flags),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMerkleProofResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMerkleProofResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SubmitTransactionRequest

@implementation SubmitTransactionRequest

@dynamic transaction;

typedef struct SubmitTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *transaction;
} SubmitTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = Nil,
        .number = SubmitTransactionRequest_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SubmitTransactionRequest__storage_, transaction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubmitTransactionRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubmitTransactionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SubmitTransactionResponse

@implementation SubmitTransactionResponse

@dynamic hash_p;

typedef struct SubmitTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
} SubmitTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SubmitTransactionResponse_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SubmitTransactionResponse__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubmitTransactionResponse class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubmitTransactionResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SubscribeTransactionsRequest

@implementation SubscribeTransactionsRequest

@dynamic hasSubscribe, subscribe;
@dynamic hasUnsubscribe, unsubscribe;
@dynamic includeMempool;
@dynamic includeInBlock;
@dynamic serializeTx;

typedef struct SubscribeTransactionsRequest__storage_ {
  uint32_t _has_storage_[1];
  TransactionFilter *subscribe;
  TransactionFilter *unsubscribe;
} SubscribeTransactionsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subscribe",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionFilter),
        .number = SubscribeTransactionsRequest_FieldNumber_Subscribe,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SubscribeTransactionsRequest__storage_, subscribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unsubscribe",
        .dataTypeSpecific.clazz = GPBObjCClass(TransactionFilter),
        .number = SubscribeTransactionsRequest_FieldNumber_Unsubscribe,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SubscribeTransactionsRequest__storage_, unsubscribe),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "includeMempool",
        .dataTypeSpecific.clazz = Nil,
        .number = SubscribeTransactionsRequest_FieldNumber_IncludeMempool,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "includeInBlock",
        .dataTypeSpecific.clazz = Nil,
        .number = SubscribeTransactionsRequest_FieldNumber_IncludeInBlock,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "serializeTx",
        .dataTypeSpecific.clazz = Nil,
        .number = SubscribeTransactionsRequest_FieldNumber_SerializeTx,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubscribeTransactionsRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubscribeTransactionsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SubscribeBlocksRequest

@implementation SubscribeBlocksRequest

@dynamic fullBlock;
@dynamic fullTransactions;
@dynamic serializeBlock;

typedef struct SubscribeBlocksRequest__storage_ {
  uint32_t _has_storage_[1];
} SubscribeBlocksRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fullBlock",
        .dataTypeSpecific.clazz = Nil,
        .number = SubscribeBlocksRequest_FieldNumber_FullBlock,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fullTransactions",
        .dataTypeSpecific.clazz = Nil,
        .number = SubscribeBlocksRequest_FieldNumber_FullTransactions,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "serializeBlock",
        .dataTypeSpecific.clazz = Nil,
        .number = SubscribeBlocksRequest_FieldNumber_SerializeBlock,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubscribeBlocksRequest class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubscribeBlocksRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockNotification

@implementation BlockNotification

@dynamic blockOneOfCase;
@dynamic type;
@dynamic blockInfo;
@dynamic marshaledBlock;
@dynamic serializedBlock;

typedef struct BlockNotification__storage_ {
  uint32_t _has_storage_[2];
  BlockNotification_Type type;
  BlockInfo *blockInfo;
  Block *marshaledBlock;
  NSData *serializedBlock;
} BlockNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BlockNotification_Type_EnumDescriptor,
        .number = BlockNotification_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockNotification__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blockInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockInfo),
        .number = BlockNotification_FieldNumber_BlockInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockNotification__storage_, blockInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "marshaledBlock",
        .dataTypeSpecific.clazz = GPBObjCClass(Block),
        .number = BlockNotification_FieldNumber_MarshaledBlock,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockNotification__storage_, marshaledBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serializedBlock",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockNotification_FieldNumber_SerializedBlock,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BlockNotification__storage_, serializedBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockNotification class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockNotification__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "block",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BlockNotification_Type_RawValue(BlockNotification *message) {
  GPBDescriptor *descriptor = [BlockNotification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockNotification_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetBlockNotification_Type_RawValue(BlockNotification *message, int32_t value) {
  GPBDescriptor *descriptor = [BlockNotification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockNotification_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void BlockNotification_ClearBlockOneOfCase(BlockNotification *message) {
  GPBDescriptor *descriptor = [BlockNotification descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum BlockNotification_Type

GPBEnumDescriptor *BlockNotification_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Connected\000Disconnected\000";
    static const int32_t values[] = {
        BlockNotification_Type_Connected,
        BlockNotification_Type_Disconnected,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BlockNotification_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BlockNotification_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BlockNotification_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BlockNotification_Type_Connected:
    case BlockNotification_Type_Disconnected:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TransactionNotification

@implementation TransactionNotification

@dynamic transactionOneOfCase;
@dynamic type;
@dynamic confirmedTransaction;
@dynamic unconfirmedTransaction;
@dynamic serializedTransaction;

typedef struct TransactionNotification__storage_ {
  uint32_t _has_storage_[2];
  TransactionNotification_Type type;
  Transaction *confirmedTransaction;
  MempoolTransaction *unconfirmedTransaction;
  NSData *serializedTransaction;
} TransactionNotification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = TransactionNotification_Type_EnumDescriptor,
        .number = TransactionNotification_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionNotification__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "confirmedTransaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = TransactionNotification_FieldNumber_ConfirmedTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransactionNotification__storage_, confirmedTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unconfirmedTransaction",
        .dataTypeSpecific.clazz = GPBObjCClass(MempoolTransaction),
        .number = TransactionNotification_FieldNumber_UnconfirmedTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransactionNotification__storage_, unconfirmedTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serializedTransaction",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionNotification_FieldNumber_SerializedTransaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TransactionNotification__storage_, serializedTransaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionNotification class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionNotification__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "transaction",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TransactionNotification_Type_RawValue(TransactionNotification *message) {
  GPBDescriptor *descriptor = [TransactionNotification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionNotification_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetTransactionNotification_Type_RawValue(TransactionNotification *message, int32_t value) {
  GPBDescriptor *descriptor = [TransactionNotification descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionNotification_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void TransactionNotification_ClearTransactionOneOfCase(TransactionNotification *message) {
  GPBDescriptor *descriptor = [TransactionNotification descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Enum TransactionNotification_Type

GPBEnumDescriptor *TransactionNotification_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unconfirmed\000Confirmed\000";
    static const int32_t values[] = {
        TransactionNotification_Type_Unconfirmed,
        TransactionNotification_Type_Confirmed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionNotification_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionNotification_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransactionNotification_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransactionNotification_Type_Unconfirmed:
    case TransactionNotification_Type_Confirmed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockInfo

@implementation BlockInfo

@dynamic hash_p;
@dynamic height;
@dynamic version;
@dynamic previousBlock;
@dynamic merkleRoot;
@dynamic timestamp;
@dynamic bits;
@dynamic nonce;
@dynamic confirmations;
@dynamic difficulty;
@dynamic nextBlockHash;
@dynamic size;
@dynamic medianTime;

typedef struct BlockInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t height;
  int32_t version;
  uint32_t bits;
  uint32_t nonce;
  int32_t confirmations;
  int32_t size;
  NSData *hash_p;
  NSData *previousBlock;
  NSData *merkleRoot;
  NSData *nextBlockHash;
  int64_t timestamp;
  double difficulty;
  int64_t medianTime;
} BlockInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "previousBlock",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_PreviousBlock,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, previousBlock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "merkleRoot",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_MerkleRoot,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, merkleRoot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Timestamp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "bits",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Bits,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, bits),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Nonce,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, nonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "confirmations",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Confirmations,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, confirmations),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "difficulty",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Difficulty,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, difficulty),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "nextBlockHash",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_NextBlockHash,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, nextBlockHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_Size,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "medianTime",
        .dataTypeSpecific.clazz = Nil,
        .number = BlockInfo_FieldNumber_MedianTime,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BlockInfo__storage_, medianTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInfo class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic hasInfo, info;
@dynamic transactionDataArray, transactionDataArray_Count;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  BlockInfo *info;
  NSMutableArray *transactionDataArray;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(BlockInfo),
        .number = Block_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionDataArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Block_TransactionData),
        .number = Block_FieldNumber_TransactionDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, transactionDataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block_TransactionData

@implementation Block_TransactionData

@dynamic txidsOrTxsOneOfCase;
@dynamic transactionHash;
@dynamic transaction;

typedef struct Block_TransactionData__storage_ {
  uint32_t _has_storage_[2];
  NSData *transactionHash;
  Transaction *transaction;
} Block_TransactionData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Block_TransactionData_FieldNumber_TransactionHash,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Block_TransactionData__storage_, transactionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = Block_TransactionData_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Block_TransactionData__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block_TransactionData class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block_TransactionData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "txidsOrTxs",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Block)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Block_TransactionData_ClearTxidsOrTxsOneOfCase(Block_TransactionData *message) {
  GPBDescriptor *descriptor = [Block_TransactionData descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Transaction

@implementation Transaction

@dynamic hash_p;
@dynamic version;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic lockTime;
@dynamic size;
@dynamic timestamp;
@dynamic confirmations;
@dynamic blockHeight;
@dynamic blockHash;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  uint32_t lockTime;
  int32_t size;
  int32_t confirmations;
  int32_t blockHeight;
  NSData *hash_p;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  NSData *blockHash;
  int64_t timestamp;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Input),
        .number = Transaction_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Output),
        .number = Transaction_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lockTime",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_LockTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, lockTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "confirmations",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_Confirmations,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, confirmations),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_BlockHeight,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_FieldNumber_BlockHash,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Input

@implementation Transaction_Input

@dynamic index;
@dynamic hasOutpoint, outpoint;
@dynamic signatureScript;
@dynamic sequence;
@dynamic value;
@dynamic previousScript;
@dynamic address;

typedef struct Transaction_Input__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  uint32_t sequence;
  Transaction_Input_Outpoint *outpoint;
  NSData *signatureScript;
  NSData *previousScript;
  NSString *address;
  int64_t value;
} Transaction_Input__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "outpoint",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Input_Outpoint),
        .number = Transaction_Input_FieldNumber_Outpoint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatureScript",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_FieldNumber_SignatureScript,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, signatureScript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_FieldNumber_Sequence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, sequence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "previousScript",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_FieldNumber_PreviousScript,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, previousScript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_FieldNumber_Address,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction_Input__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Input class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Input__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Input_Outpoint

@implementation Transaction_Input_Outpoint

@dynamic hash_p;
@dynamic index;

typedef struct Transaction_Input_Outpoint__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSData *hash_p;
} Transaction_Input_Outpoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_Outpoint_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Input_Outpoint__storage_, hash_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Input_Outpoint_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Input_Outpoint__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Input_Outpoint class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Input_Outpoint__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Transaction_Input)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Output

@implementation Transaction_Output

@dynamic index;
@dynamic value;
@dynamic pubkeyScript;
@dynamic address;
@dynamic scriptClass;
@dynamic disassembledScript;

typedef struct Transaction_Output__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  NSData *pubkeyScript;
  NSString *address;
  NSString *scriptClass;
  NSString *disassembledScript;
  int64_t value;
} Transaction_Output__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Output_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Output__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Output_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Output__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubkeyScript",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Output_FieldNumber_PubkeyScript,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Output__storage_, pubkeyScript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Output_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Output__storage_, address),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scriptClass",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Output_FieldNumber_ScriptClass,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_Output__storage_, scriptClass),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "disassembledScript",
        .dataTypeSpecific.clazz = Nil,
        .number = Transaction_Output_FieldNumber_DisassembledScript,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_Output__storage_, disassembledScript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Output class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Output__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MempoolTransaction

@implementation MempoolTransaction

@dynamic hasTransaction, transaction;
@dynamic addedTime;
@dynamic addedHeight;
@dynamic fee;
@dynamic feePerKb;
@dynamic startingPriority;

typedef struct MempoolTransaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t addedHeight;
  Transaction *transaction;
  int64_t addedTime;
  int64_t fee;
  int64_t feePerKb;
  double startingPriority;
} MempoolTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction),
        .number = MempoolTransaction_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MempoolTransaction__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addedTime",
        .dataTypeSpecific.clazz = Nil,
        .number = MempoolTransaction_FieldNumber_AddedTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MempoolTransaction__storage_, addedTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "addedHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = MempoolTransaction_FieldNumber_AddedHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MempoolTransaction__storage_, addedHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fee",
        .dataTypeSpecific.clazz = Nil,
        .number = MempoolTransaction_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MempoolTransaction__storage_, fee),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feePerKb",
        .dataTypeSpecific.clazz = Nil,
        .number = MempoolTransaction_FieldNumber_FeePerKb,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MempoolTransaction__storage_, feePerKb),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "startingPriority",
        .dataTypeSpecific.clazz = Nil,
        .number = MempoolTransaction_FieldNumber_StartingPriority,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MempoolTransaction__storage_, startingPriority),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MempoolTransaction class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MempoolTransaction__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnspentOutput

@implementation UnspentOutput

@dynamic hasOutpoint, outpoint;
@dynamic pubkeyScript;
@dynamic value;
@dynamic isCoinbase;
@dynamic blockHeight;

typedef struct UnspentOutput__storage_ {
  uint32_t _has_storage_[1];
  int32_t blockHeight;
  Transaction_Input_Outpoint *outpoint;
  NSData *pubkeyScript;
  int64_t value;
} UnspentOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outpoint",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Input_Outpoint),
        .number = UnspentOutput_FieldNumber_Outpoint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnspentOutput__storage_, outpoint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pubkeyScript",
        .dataTypeSpecific.clazz = Nil,
        .number = UnspentOutput_FieldNumber_PubkeyScript,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnspentOutput__storage_, pubkeyScript),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = UnspentOutput_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnspentOutput__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isCoinbase",
        .dataTypeSpecific.clazz = Nil,
        .number = UnspentOutput_FieldNumber_IsCoinbase,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = UnspentOutput_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnspentOutput__storage_, blockHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnspentOutput class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnspentOutput__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionFilter

@implementation TransactionFilter

@dynamic addressesArray, addressesArray_Count;
@dynamic outpointsArray, outpointsArray_Count;
@dynamic dataElementsArray, dataElementsArray_Count;
@dynamic allTransactions;

typedef struct TransactionFilter__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSMutableArray *outpointsArray;
  NSMutableArray *dataElementsArray;
} TransactionFilter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionFilter_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionFilter__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outpointsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Transaction_Input_Outpoint),
        .number = TransactionFilter_FieldNumber_OutpointsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionFilter__storage_, outpointsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataElementsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionFilter_FieldNumber_DataElementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionFilter__storage_, dataElementsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "allTransactions",
        .dataTypeSpecific.clazz = Nil,
        .number = TransactionFilter_FieldNumber_AllTransactions,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionFilter class]
                                     rootClass:[BchrpcRoot class]
                                          file:BchrpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionFilter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
